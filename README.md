# Шаблон Микросервиса на Python (FastAPI + DDD)

Этот репозиторий представляет собой современный шаблон (boilerplate) для создания высокопроизводительных микросервисов на Python. Он использует фреймворк **FastAPI** и архитектурно следует принципам **Domain-Driven Design (DDD)**, обеспечивая чистоту, тестируемость и масштабируемость кода.

Все компоненты запускаются и оркестрируются с помощью **Docker Compose**, что гарантирует изолированность и воспроизводимость окружения.

## Основные Технологии

Этот шаблон включает полный стек технологий, необходимый для Production-Ready микросервиса:

|   |   |
|---|---|
|**Компонент**|**Назначение**|
|**Фреймворк**|**FastAPI** (ASGI) для высокой производительности HTTP-сервисов.|
|**База данных**|**PostgreSQL** (через SQLAlchemy Async) для надежного асинхронного доступа к данным.|
|**Кэширование**|**Redis** для быстрого доступа к данным и уменьшения нагрузки на БД.|
|**Очереди сообщений**|**RabbitMQ** для асинхронной обработки задач и межсервисного взаимодействия.|
|**DI/IoC**|**Punq** (Inversion of Control) для управления и внедрения зависимостей.|
|**Миграции БД**|**Alembic** для версионирования схемы базы данных.|
|**Архитектура**|**Domain-Driven Design (DDD)** для разделения ответственности и масштабируемости.|

## Структура Проекта

Проект организован в соответствии с принципами Чистой Архитектуры (Clean Architecture) и DDD:

```
src/
├── api/             # HTTP-слой: Маршруты (Routes) и Схемы запросов/ответов (Pydantic models).
├── config.py        # Файл конфигурации (BaseSettings) для всех сервисов.
├── container.py     # Контейнер Punq: регистрация и разрешение зависимостей.
├── repositories/    # Слой доступа к данным: Репозитории для DB, Cache (Redis), RabbitMQ.
├── usecases/        # Слой Бизнес-логики (Application/Domain Layer): Содержит Use Cases.
├── utils/           # Вспомогательные функции (например, security.py).
└── main.py          # Точка входа для Uvicorn (HTTP-сервис).
```

## Установка и Запуск

Для работы с проектом вам потребуется установленный **Docker** и **Docker Compose**.

### 1. Подготовка `.env` файла

Создайте файл `.env` в корне проекта, скопировав его содержимое из `.env.example`. **Крайне важно** заполнить все секретные данные (пароли, ключи), особенно **`SECURITY_SECRET_KEY`**, который используется для подписи JWT.

### 2. Запуск сервисов

Используйте Docker Compose для сборки образов и запуска всех компонентов:

```
docker-compose up --build -d
```

Сервисы, которые будут запущены: `micro_service` (FastAPI), `consume_worker` (воркер RabbitMQ), `db` (PostgreSQL), `redis`, `rabbitmq`.

### 3. Выполнение миграций базы данных

После первого запуска (и при каждом изменении моделей SQLAlchemy) необходимо применить миграции:

```
docker-compose exec micro_service bash -c "alembic upgrade head"
```

### 4. Проверка статуса

Убедитесь, что все сервисы запущены и работают без сбоев:

```
docker-compose ps
```

## Использование API и Аутентификация

Основной HTTP-сервис доступен по адресу `http://localhost:8000`.

### Документация

- **Swagger UI (Интерактивная документация):** `http://localhost:8000/docs`
    
- **Redoc:** `http://localhost:8000/redoc`
    

### Модуль Аутентификации

Шаблон включает полный цикл аутентификации на основе **Access JWT** и **Refresh Token**.

|   |   |   |
|---|---|---|
|**Метод**|**Маршрут**|**Описание**|
|`POST`|`/api/v1/auth/register`|Регистрация нового пользователя.|
|`POST`|`/api/v1/auth/login`|Вход, получение `access_token` и `refresh_token`.|
|`POST`|`/api/v1/auth/refresh`|Обновление `access_token` с помощью `refresh_token`.|

## Особенности Реализации

### 1. Инвалидация Кэша

Модуль кэширования (`DBUserRepository`) автоматически использует Redis для всех операций чтения. При этом, при записи (`create_user`, `update_user_password`), срабатывает метод `_invalidate_user_cache`, который **удаляет** связанные ключи из Redis, гарантируя актуальность данных.

### 2. Управление Зависимостями

Контейнер **Punq** (`src/container.py`) обеспечивает четкое разделение между конфигурацией, репозиториями и бизнес-логикой. Это позволяет легко подменять реализации (например, использовать mock-репозиторий в тестах) и контролировать жизненный цикл всех компонентов, включая асинхронные сессии SQLAlchemy и Redis.

### 3. Обработка Ошибок

Все ошибки на уровне бизнес-логики (Use Cases) используют кастомные исключения (`AuthenticationError`, `NotFoundDatabaseError`), которые затем перехватываются на уровне API-роутов и преобразуются в соответствующие HTTP-статусы (401, 404, 409).
